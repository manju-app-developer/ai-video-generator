<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Narratives: A Generative Documentary Experience</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --glow-color: rgba(0, 255, 255, 0.7);
            --primary-color: #00ffff;
            --dark-bg: #0a0a0a;
        }
        body {
            font-family: 'Exo 2', sans-serif;
            background-color: var(--dark-bg);
            color: #e5e5e5;
        }
        #background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.5;
        }
        .glass-bg {
            background: rgba(10, 10, 10, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 255, 0.2);
        }
        .glow-border {
            box-shadow: 0 0 15px var(--glow-color), 0 0 30px var(--glow-color), 0 0 60px black;
        }
        
        /* -- Enhanced Player Controls Styling -- */
        #controls-container {
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
        }
        #controls-container.controls-hidden {
            opacity: 0;
            transform: translateY(100%);
            pointer-events: none;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 5px;
            background-color: rgba(0, 255, 255, 0.15);
            transition: height 0.2s ease;
            cursor: pointer;
        }
        .progress-bar-container:hover {
            height: 8px;
        }
        .progress-bar-inner {
            background-color: var(--primary-color);
            height: 100%;
            pointer-events: none;
            box-shadow: 0 0 8px var(--glow-color);
        }

        /* Volume Slider Customization */
        input[type=range].volume-slider {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range].volume-slider:focus {
            outline: none;
        }
        input[type=range].volume-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(0, 255, 255, 0.3);
            border-radius: 5px;
        }
        input[type=range].volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -5px; /* Center thumb on track */
            transition: transform 0.2s ease;
            box-shadow: 0 0 5px var(--glow-color);
        }
        input[type=range].volume-slider:hover::-webkit-slider-thumb {
             transform: scale(1.1);
        }

        .btn-primary {
            background-color: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            transition: all 0.3s ease;
            box-shadow: inset 0 0 5px rgba(0, 255, 255, 0.4);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px var(--glow-color);
            transform: translateY(-2px);
        }
        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: rgba(0, 255, 255, 0.3);
            color: rgba(0, 255, 255, 0.3);
        }
        .btn-secondary {
            background-color: transparent;
            color: #e5e5e5;
            transition: all 0.2s ease;
            border-radius: 9999px;
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: rgba(0, 255, 255, 0.15);
            transform: scale(1.1);
            color: var(--primary-color);
        }
        .btn-secondary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .loader-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
        }
        .buffer-loader {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            box-shadow: 0 0 10px var(--glow-color);
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        .ken-burns {
            animation: kenburns-effect 20s ease-in-out infinite alternate;
        }
        @keyframes kenburns-effect {
            0% { transform: scale(1.1) translate(0, 0); }
            100% { transform: scale(1.25) translate(2%, -2%); }
        }
        #end-screen {
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
        }

        #prompt-modal .glass-bg {
             border: 1px solid rgba(0, 255, 255, 0.4);
        }
        #watermark {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 1.25rem;
            color: rgba(255, 255, 255, 0.7);
            z-index: 15;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body class="w-full min-h-screen flex items-center justify-center p-2 sm:p-4">
    <canvas id="background-animation"></canvas>

    <div id="app-container" class="w-full max-w-7xl mx-auto flex flex-col gap-4">
        
        <div id="video-player" class="glass-bg rounded-xl sm:rounded-2xl w-full aspect-video flex-shrink-0 relative overflow-hidden flex items-center justify-center glow-border cursor-pointer">
            
            <div id="loading-state" class="hidden text-center p-4 sm:p-8 loader-container z-10">
                <div class="buffer-loader"></div>
                <p id="loading-text" class="text-gray-300 mt-4 text-md sm:text-lg font-medium">Generating your narrative...</p>
            </div>

            <img id="display-image" src="" class="absolute top-0 left-0 w-full h-full object-cover transition-opacity duration-1000 opacity-0 z-0" alt="Generated visual">
            <div class="absolute inset-0 bg-gradient-to-t from-black/70 via-transparent to-black/30 z-10"></div>
            
            <div id="watermark">Created by Manju</div>

            <div id="end-screen" class="absolute inset-0 flex-col items-center justify-center gap-6 hidden fade-in p-4 cursor-default z-20">
                <h2 class="text-3xl sm:text-4xl md:text-5xl font-bold text-white text-center">Thanks for watching</h2>
                <div id="end-screen-buttons" class="flex items-center gap-4 mt-4"></div>
            </div>

            <div id="controls-container" class="absolute bottom-0 left-0 w-full p-2 sm:p-3 pt-2 flex flex-col justify-end transition-all duration-300 hidden bg-gradient-to-t from-black/80 to-transparent cursor-default z-20">
                <div class="w-full rounded-full progress-bar-container mb-2">
                    <div id="progress-bar" class="bg-blue-500 h-full rounded-full progress-bar-inner" style="width: 0%"></div>
                </div>
                <div class="flex items-center justify-between gap-2 sm:gap-4 w-full">
                    <div class="flex items-center gap-1 sm:gap-2">
                        <button id="play-pause-button" class="p-2 btn-secondary text-white">
                            <svg id="play-icon" class="w-6 h-6 sm:w-7 sm:h-7" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M7 6V18L17 12L7 6Z"></path></svg>
                            <svg id="pause-icon" class="w-6 h-6 sm:w-7 sm:h-7 hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18H10V6H6V18ZM14 6V18H18V6H14Z"></path></svg>
                        </button>
                        <button id="prev-scene-button" class="p-2 btn-secondary text-white disabled:opacity-30">
                            <svg class="w-5 h-5 sm:w-6 sm:h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg>
                        </button>
                        <button id="next-scene-button" class="p-2 btn-secondary text-white disabled:opacity-30">
                           <svg class="w-5 h-5 sm:w-6 sm:h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>
                        </button>
                        <div class="flex items-center group">
                             <button id="volume-button" class="p-2 btn-secondary">
                                 <svg id="volume-high-icon" class="w-5 h-5 sm:w-6 sm:h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
                                 <svg id="volume-muted-icon" class="w-5 h-5 sm:w-6 sm:h-6 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
                             </button>
                             <input id="volume-slider" type="range" min="0" max="1" step="0.01" value="1" class="volume-slider w-0 group-hover:w-20 transition-all duration-300">
                        </div>
                    </div>
                    <div class="flex items-center gap-2 text-xs sm:text-sm font-mono">
                        <span id="current-time">00:00</span>
                        <span>/</span>
                        <span id="total-duration">00:00</span>
                    </div>
                    <div class="flex items-center gap-1 sm:gap-2">
                        <button id="fullscreen-button" class="p-2 btn-secondary">
                            <svg id="fullscreen-enter-icon" class="w-5 h-5 sm:w-6 sm:h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" /></svg>
                            <svg id="fullscreen-exit-icon" class="w-5 h-5 sm:w-6 sm:h-6 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5M15 15l5.25 5.25" /></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="prompt-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50">
        <div class="glass-bg rounded-2xl p-6 sm:p-8 max-w-lg w-full transform transition-all fade-in glow-border">
            <h2 class="text-xl sm:text-2xl font-bold text-white mb-2">Create a New Narrative</h2>
            <p class="text-gray-400 mb-6 text-sm sm:text-base">Enter a topic and select a duration for your personalized documentary.</p>
            <textarea id="initial-prompt-input" rows="3" class="w-full bg-gray-900/50 border border-cyan-400/30 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-cyan-400 text-sm sm:text-base" placeholder="e.g., Explain the concept of quantum foam."></textarea>
            <div class="mt-4">
                <label for="duration-input" class="block text-sm font-medium text-gray-300">Target Duration (minutes)</label>
                <input type="range" id="duration-input" min="1" max="5" value="2" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-2">
                <div class="text-center text-gray-400 mt-1 text-sm"><span id="duration-label">2</span> minutes</div>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="generate-button" class="px-5 py-2.5 sm:px-6 sm:py-2.5 rounded-lg btn-primary font-semibold text-sm sm:text-base" disabled>Generate</button>
            </div>
        </div>
    </div>
    
    <audio id="audio-player" class="hidden"></audio>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Canvas Background Animation ---
        const canvas = document.getElementById('background-animation');
        const ctx = canvas.getContext('2d');
        let particles = [];
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        class Particle { constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.vx = (Math.random() - 0.5) * 0.3; this.vy = (Math.random() - 0.5) * 0.3; this.radius = Math.random() * 1.5; } update() { this.x += this.vx; this.y += this.vy; if (this.x < 0 || this.x > canvas.width) this.vx *= -1; if (this.y < 0 || this.y > canvas.height) this.vy *= -1; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.fill(); } }
        function initParticles() { particles = []; let numParticles = Math.min(150, (canvas.width * canvas.height) / 9000); for (let i = 0; i < numParticles; i++) { particles.push(new Particle()); } }
        function animateParticles() { ctx.clearRect(0, 0, canvas.width, canvas.height); particles.forEach(p => { p.update(); p.draw(); }); for (let i = 0; i < particles.length; i++) { for (let j = i; j < particles.length; j++) { const dist = Math.hypot(particles[i].x - particles[j].x, particles[i].y - particles[j].y); if (dist < 120) { ctx.beginPath(); ctx.moveTo(particles[i].x, particles[i].y); ctx.lineTo(particles[j].x, particles[j].y); ctx.strokeStyle = `rgba(0, 255, 255, ${1 - dist / 120})`; ctx.lineWidth = 0.5; ctx.stroke(); } } } requestAnimationFrame(animateParticles); }
        resizeCanvas(); initParticles(); animateParticles(); window.addEventListener('resize', () => { resizeCanvas(); initParticles(); });

        // --- DOM Elements ---
        const videoPlayer = document.getElementById('video-player');
        const promptModal = document.getElementById('prompt-modal');
        const generateButton = document.getElementById('generate-button');
        const initialPromptInput = document.getElementById('initial-prompt-input');
        const durationInput = document.getElementById('duration-input');
        const durationLabel = document.getElementById('duration-label');
        const loadingState = document.getElementById('loading-state');
        const loadingText = document.getElementById('loading-text');
        const controlsContainer = document.getElementById('controls-container');
        const displayImage = document.getElementById('display-image');
        const progressBarContainer = document.querySelector('.progress-bar-container');
        const progressBar = document.getElementById('progress-bar');
        const playPauseButton = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const prevSceneButton = document.getElementById('prev-scene-button');
        const nextSceneButton = document.getElementById('next-scene-button');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
        const fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');
        const endScreen = document.getElementById('end-screen');
        const endScreenButtons = document.getElementById('end-screen-buttons');
        const audioPlayer = document.getElementById('audio-player');
        const currentTimeEl = document.getElementById('current-time');
        const totalDurationEl = document.getElementById('total-duration');
        const volumeButton = document.getElementById('volume-button');
        const volumeHighIcon = document.getElementById('volume-high-icon');
        const volumeMutedIcon = document.getElementById('volume-muted-icon');
        const volumeSlider = document.getElementById('volume-slider');
        const watermark = document.getElementById('watermark');

        // --- App State ---
        let state = {
            scriptSegments: [],
            currentSegmentIndex: 0,
            isPlaying: false,
            topicSlug: "",
            controlsTimeout: null,
            encodedVideoUrl: null,
            isEncoding: false,
            encodingProgress: 0,
            encodingFailed: false,
            isDocumentaryActive: false,
            allAssetsGenerated: false,
            initialPrompt: "",
            initialDuration: 2,
        };
        
        // --- Event Listeners ---
        generateButton.addEventListener('click', handleInitialGeneration);
        playPauseButton.addEventListener('click', togglePlayback);
        prevSceneButton.addEventListener('click', playPreviousSegment);
        nextSceneButton.addEventListener('click', () => playNextSegment());
        audioPlayer.addEventListener('ended', () => playNextSegment(true));
        audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
        initialPromptInput.addEventListener('input', () => { generateButton.disabled = initialPromptInput.value.trim() === ''; });
        durationInput.addEventListener('input', () => { durationLabel.textContent = durationInput.value; });
        fullscreenButton.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', updateFullscreenIcon);
        progressBarContainer.addEventListener('click', handleSeek);
        videoPlayer.addEventListener('mousemove', showControls);
        videoPlayer.addEventListener('mouseleave', () => { if (state.isPlaying) resetControlsTimeout(); });
        
        controlsContainer.addEventListener('click', e => e.stopPropagation());
        volumeButton.addEventListener('click', toggleMute);
        volumeSlider.addEventListener('input', handleVolumeChange);
        document.addEventListener('keydown', handleKeyboardShortcuts);

        // Robust Tap Detection for Touch Devices & Click for Desktop
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouchDevice) {
            let touchStartX = 0, touchStartY = 0;
            videoPlayer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].screenX;
                    touchStartY = e.touches[0].screenY;
                }
            }, { passive: true });
            videoPlayer.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 1) {
                    const touchEndX = e.changedTouches[0].screenX;
                    const touchEndY = e.changedTouches[0].screenY;
                    if (Math.abs(touchEndX - touchStartX) < 10 && Math.abs(touchEndY - touchStartY) < 10) {
                        handlePlayerClick(e);
                    }
                }
            });
        } else {
            videoPlayer.addEventListener('click', handlePlayerClick);
        }


        // --- Core Functions ---
        async function handleInitialGeneration() {
            const prompt = initialPromptInput.value.trim();
            if (!prompt) return;
            
            generateButton.disabled = true;
            generateButton.innerHTML = `<div class="w-5 h-5 border-2 border-cyan-400/50 border-t-cyan-400 rounded-full animate-spin inline-block mr-2"></div>Generating...`;

            state.initialPrompt = prompt;
            state.initialDuration = parseInt(durationInput.value, 10);
            
            resetStateForNewDocumentary();

            const segmentsCount = state.initialDuration * 4; 

            state.topicSlug = prompt.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '').substring(0, 50);
            
            try {
                const systemPrompt = `You are an acclaimed science communicator and documentary director. Create a script based on verifiable scientific facts.
- The target duration is ${state.initialDuration} minutes. Structure the script into exactly ${segmentsCount} logical paragraphs.
- Each paragraph must be concise, 35-45 words, to control segment duration.
- For EACH paragraph, provide a detailed, cinematic image prompt for a photorealistic, scientifically accurate visual.
- CRITICAL SAFETY RULE: Do NOT include names of any specific people in image prompts. Describe roles generically (e.g., "a visionary engineer").
- Respond ONLY with a valid JSON array of objects, each with "text" and "imagePrompt" keys.`;
                
                const scriptData = await generateText(systemPrompt, prompt);
                if (!scriptData || !Array.isArray(scriptData) || scriptData.length === 0) throw new Error("Invalid script format received.");
                
                state.scriptSegments = new Array(scriptData.length).fill(null);
                
                const firstSegment = await generateSegmentAssets(scriptData[0].text, scriptData[0].imagePrompt);
                state.scriptSegments[0] = firstSegment;
                
                promptModal.classList.add('hidden');
                controlsContainer.classList.remove('hidden');
                
                startDocumentary();
                generateRemainingScenesInBackground(scriptData);

            } catch (error) {
                console.error('Error during initial generation:', error);
                showError("Script generation failed. Please try another topic.");
            }
        }

        async function generateRemainingScenesInBackground(scriptData) {
            const promises = [];
            for (let i = 1; i < scriptData.length; i++) {
                const promise = (async () => {
                    try {
                        const segment = await generateSegmentAssets(scriptData[i].text, scriptData[i].imagePrompt);
                        state.scriptSegments[i] = segment;
                        updateTotalDurationUI();
                    } catch (error) {
                        console.error(`Failed to generate scene ${i + 1}:`, error);
                        state.scriptSegments[i] = { error: true, text: `Error generating scene ${i + 1}. Skipping.` };
                    }
                })();
                promises.push(promise);
            }
            await Promise.all(promises);
            state.allAssetsGenerated = true;
            console.log("All assets generated, starting background encoding.");
            startBackgroundEncoding();
        }
        
        async function generateSegmentAssets(text, imagePrompt) {
            let imageUrl;
            try {
                imageUrl = await generateImage(imagePrompt);
            } catch (error) {
                console.error(`Failed to generate image for prompt "${imagePrompt}". Using fallback.`, error);
                imageUrl = `https://placehold.co/1920x1080/0a0a0a/333333?text=Visual+Could+Not+Be+Generated`;
            }
            const audioUrl = await generateAudio(text);
            const duration = await getAudioDuration(audioUrl);
            return { text, imageUrl, audioUrl, duration };
        }
        
        // --- Playback Controls ---
        function startDocumentary() {
            state.isDocumentaryActive = true;
            state.currentSegmentIndex = 0;
            watermark.style.display = 'block';
            updateTotalDurationUI();
            playSegment(state.currentSegmentIndex);
            showControls();
        }

        function playPreviousSegment() {
            if (state.currentSegmentIndex > 0) {
                playSegment(state.currentSegmentIndex - 1);
            }
        }

        async function playNextSegment(autoAdvance = false) {
            if (state.currentSegmentIndex >= state.scriptSegments.length - 1) {
                if (autoAdvance) completeDocumentary();
                return;
            }

            const nextIndex = state.currentSegmentIndex + 1;

            if (!state.scriptSegments[nextIndex]) {
                pausePlayback(); 
                
                const loadingStartTime = Date.now();

                while (!state.scriptSegments[nextIndex]) {
                    if (Date.now() - loadingStartTime > 45000) { // 45-second timeout
                        showError("Generation of the next scene is taking too long. Please try again.");
                        return;
                    }
                    await new Promise(res => setTimeout(res, 250));
                }
            }

            const nextSegment = state.scriptSegments[nextIndex];

            if (nextSegment.error) {
                console.warn(`Skipping scene ${nextIndex + 1} due to generation error.`);
                await new Promise(res => setTimeout(res, 500));
                state.currentSegmentIndex++;
                playNextSegment(autoAdvance);
                return;
            }

            playSegment(nextIndex);
        }

        function playSegment(index, startTime = 0) {
            const segment = state.scriptSegments[index];
            if (!segment || segment.error) return;
            
            state.currentSegmentIndex = index;

            displayImage.style.opacity = 0;
            displayImage.classList.remove('ken-burns');
            
            setTimeout(() => {
                displayImage.src = segment.imageUrl;
                displayImage.onload = () => {
                    displayImage.style.opacity = 1;
                    displayImage.classList.add('ken-burns');
                };
            }, 300);
            
            audioPlayer.src = segment.audioUrl;
            audioPlayer.onloadedmetadata = () => {
                audioPlayer.currentTime = startTime;
                if(state.isDocumentaryActive) resumePlayback();
            }
            updateNavButtons();
        }
        
        function completeDocumentary() {
            state.isDocumentaryActive = false;
            pausePlayback();
            displayImage.style.opacity = 0;
            watermark.style.display = 'none';
            endScreen.classList.remove('hidden');
            endScreen.style.display = 'flex';
            showControls(true);
            prepareAndShowEndScreenButtons();
        }

        function updateNavButtons() {
            prevSceneButton.disabled = state.currentSegmentIndex === 0;
            const nextSegmentExists = state.currentSegmentIndex < state.scriptSegments.length - 1;
            nextSceneButton.disabled = !nextSegmentExists;
        }

        function togglePlayback() { if (state.isPlaying) pausePlayback(); else resumePlayback(); }
        
        function pausePlayback() { 
            state.isPlaying = false; 
            audioPlayer.pause(); 
            playIcon.classList.remove('hidden'); 
            pauseIcon.classList.add('hidden'); 
            displayImage.style.animationPlayState = 'paused'; 
            showControls(true);
        }

        function resumePlayback() { 
            if (!state.scriptSegments[state.currentSegmentIndex] || !audioPlayer.src) return; 
            state.isPlaying = true; 
            audioPlayer.play().catch(e => console.error("Audio play failed:", e)); 
            playIcon.classList.add('hidden'); 
            pauseIcon.classList.remove('hidden'); 
            displayImage.style.animationPlayState = 'running'; 
            resetControlsTimeout();
        }

        function handleTimeUpdate() {
            const segment = state.scriptSegments[state.currentSegmentIndex];
            if (!segment || segment.error) return;

            let totalElapsed = 0;
            for(let i=0; i < state.currentSegmentIndex; i++) {
                totalElapsed += state.scriptSegments[i]?.duration || 0;
            }
            totalElapsed += audioPlayer.currentTime;

            let totalDuration = 0;
            state.scriptSegments.forEach(seg => {
                if (seg && !seg.error) totalDuration += seg.duration;
            });

            if (totalDuration > 0) {
                progressBar.style.width = `${(totalElapsed / totalDuration) * 100}%`;
                currentTimeEl.textContent = formatTime(totalElapsed);
            }
        }
        
        function handleSeek(e) {
            let totalDuration = 0;
            state.scriptSegments.forEach(seg => { if (seg && !seg.error) totalDuration += seg.duration; });
            if (totalDuration === 0) return;

            const rect = progressBarContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = clickX / rect.width;
            const seekTime = percentage * totalDuration;

            let timeCursor = 0;
            for(let i = 0; i < state.scriptSegments.length; i++) {
                const segment = state.scriptSegments[i];
                if (!segment || segment.error) continue;
                if (seekTime < timeCursor + segment.duration) {
                    const seekInSegment = seekTime - timeCursor;
                    playSegment(i, seekInSegment);
                    break;
                }
                timeCursor += segment.duration;
            }
        }

        // --- UI & State Management ---
        function resetStateForNewDocumentary() {
             state.scriptSegments = [];
             state.currentSegmentIndex = 0;
             state.isPlaying = false;
             state.encodedVideoUrl = null;
             state.isEncoding = false;
             state.encodingProgress = 0;
             state.encodingFailed = false;
             state.isDocumentaryActive = false;
             state.allAssetsGenerated = false;
             endScreen.classList.add('hidden');
             watermark.style.display = 'none';
             progressBar.style.width = '0%';
             currentTimeEl.textContent = '00:00';
             totalDurationEl.textContent = '00:00';
        }

        async function toggleFullscreen() {
            const isMobile = window.innerWidth < 768;
            if (!document.fullscreenElement) {
                try {
                    await videoPlayer.requestFullscreen();
                    if (isMobile && screen.orientation && typeof screen.orientation.lock === 'function') {
                        await screen.orientation.lock('landscape').catch(err => {});
                    }
                } catch (err) {
                    console.error(`Fullscreen Error: ${err.message}`);
                }
            } else {
                 try {
                      if (screen.orientation && typeof screen.orientation.unlock === 'function') {
                           screen.orientation.unlock();
                      }
                      await document.exitFullscreen();
                 } catch (err) {
                       console.error(`Exit Fullscreen Error: ${err.message}`);
                 }
            }
        }


        function updateFullscreenIcon() {
            const isFullscreen = !!document.fullscreenElement;
            fullscreenEnterIcon.classList.toggle('hidden', isFullscreen);
            fullscreenExitIcon.classList.toggle('hidden', !isFullscreen);
        }

        function updateTotalDurationUI() {
            let totalDuration = state.scriptSegments.reduce((acc, seg) => acc + (seg && !seg.error ? seg.duration : 0), 0);
            totalDurationEl.textContent = formatTime(totalDuration);
        }

        function handlePlayerClick(e) {
            if (state.isDocumentaryActive) {
                controlsContainer.classList.toggle('controls-hidden');
                if (!controlsContainer.classList.contains('controls-hidden')) {
                    resetControlsTimeout();
                } else {
                    clearTimeout(state.controlsTimeout);
                }
            }
        }

        function showControls(isPermanent = false) {
            controlsContainer.classList.remove('controls-hidden');
            if (isPermanent) {
                clearTimeout(state.controlsTimeout);
            } else if (state.isPlaying) {
                resetControlsTimeout();
            }
        }
        
        function hideControls() {
             if (state.isPlaying && endScreen.classList.contains('hidden')) {
                   controlsContainer.classList.add('controls-hidden');
             }
        }

        function resetControlsTimeout() {
            clearTimeout(state.controlsTimeout);
            state.controlsTimeout = setTimeout(hideControls, 5000);
        }

        // --- Download and End Screen ---
        async function prepareAndShowEndScreenButtons() {
            endScreenButtons.innerHTML = ''; // Clear previous buttons
            
            // Replay Button
            const replayButton = document.createElement('button');
            replayButton.className = 'px-6 py-3 rounded-lg btn-secondary font-semibold text-white text-lg border border-cyan-400/50';
            replayButton.textContent = 'Replay';
            replayButton.onclick = () => {
                endScreen.classList.add('hidden');
                endScreen.style.display = ""; // Reset the inline display style
                startDocumentary();
            };
            
            // Download Button
            const downloadButton = document.createElement('button');
            downloadButton.className = 'px-6 py-3 rounded-lg btn-primary font-semibold text-lg';
            
            endScreenButtons.appendChild(replayButton);
            endScreenButtons.appendChild(downloadButton);

            const checkEncodingStatus = () => {
                if (state.encodedVideoUrl) {
                    downloadButton.innerHTML = `Download Video`;
                    downloadButton.disabled = false;
                    downloadButton.onclick = () => triggerDownload(state.encodedVideoUrl, `${state.topicSlug}-documentary.webm`);
                } else if (state.encodingFailed) {
                    downloadButton.innerHTML = `Encoding Failed`;
                    downloadButton.disabled = true;
                } else if (state.isEncoding) {
                    downloadButton.innerHTML = `<div class="w-5 h-5 border-2 border-cyan-400/50 border-t-cyan-400 rounded-full animate-spin inline-block mr-2"></div>Transcoding... ${state.encodingProgress}%`;
                    downloadButton.disabled = true;
                    setTimeout(checkEncodingStatus, 1000);
                } else if (state.allAssetsGenerated) {
                    downloadButton.innerHTML = `Download Error`;
                    downloadButton.disabled = true;
                } else { 
                    downloadButton.innerHTML = `<div class="w-5 h-5 border-2 border-cyan-400/50 border-t-cyan-400 rounded-full animate-spin inline-block mr-2"></div>Preparing assets...`;
                    downloadButton.disabled = true;
                    setTimeout(checkEncodingStatus, 1000);
                }
            };
            checkEncodingStatus();
        }
        
        async function startBackgroundEncoding() {
             if (state.isEncoding || state.encodedVideoUrl) return; 
             console.log("Starting background video encoding...");
             state.isEncoding = true;
             state.encodingFailed = false;
             try {
                 const videoBlobUrl = await encodeFullVideo();
                 state.encodedVideoUrl = videoBlobUrl;
                 console.log("Background video encoding complete.");
             } catch(error) {
                 console.error("Background video encoding failed:", error);
                 state.encodingFailed = true;
             } finally {
                 state.isEncoding = false;
             }
        }

        // =================================================================
        // == START: CORRECTED VIDEO ENCODING FUNCTION
        // =================================================================
        async function encodeFullVideo() {
            console.log("Starting direct FFmpeg encoding...");

            // FIX: Ensure FFmpeg is accessed from the window object and check for its existence
            if (!window.FFmpeg || !window.FFmpeg.createFFmpeg) {
                throw new Error("FFmpeg library is not loaded correctly.");
            }
            const { createFFmpeg, fetchFile } = window.FFmpeg;

            const ffmpeg = createFFmpeg({
                log: true,
                // The corePath MUST match the version of the ffmpeg.js script loaded in the HTML
                corePath: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js",
            });

            try {
                await ffmpeg.load();
                
                // Load a font for the watermark from a reliable source
                const fontUrl = 'https://raw.githubusercontent.com/google/fonts/main/ofl/exo2/Exo2-Regular.ttf';
                ffmpeg.FS('writeFile', 'font.ttf', await fetchFile(fontUrl));

                const validSegments = state.scriptSegments.filter(seg => seg && !seg.error && seg.imageUrl && seg.audioUrl);
                if (validSegments.length === 0) {
                    throw new Error("No valid segments with assets found to encode.");
                }

                const concatFileContent = [];
                let totalProcessedDuration = 0;
                const totalDuration = state.scriptSegments.reduce((acc, s) => acc + (s?.duration || 0), 0);


                // Step 1: Process each segment into an individual WebM clip
                for (let i = 0; i < validSegments.length; i++) {
                    const segment = validSegments[i];
                    const imageName = `image-${i}.png`;
                    const audioName = `audio-${i}.wav`;
                    const clipName = `clip-${i}.webm`; // CHANGE: Use .webm extension for clips

                    // Write image and audio files to FFmpeg's virtual file system
                    ffmpeg.FS('writeFile', imageName, await fetchFile(segment.imageUrl));
                    ffmpeg.FS('writeFile', audioName, await fetchFile(segment.audioUrl));
                    
                    // CHANGE: FFmpeg command to create a WebM clip with VP9/Opus codecs
                    await ffmpeg.run(
                        '-loop', '1',
                        '-i', imageName,
                        '-i', audioName,
                        '-vf', "drawtext=fontfile=font.ttf:text='Created by Manju':fontcolor=white@0.8:fontsize=36:x=w-text_w-20:y=h-text_h-20",
                        '-c:v', 'libvpx-vp9',
                        '-crf', '35',
                        '-b:v', '0',
                        '-c:a', 'libopus',
                        '-b:a', '128k',
                        '-pix_fmt', 'yuv420p',
                        '-shortest',
                        clipName
                    );

                    concatFileContent.push(`file '${clipName}'`);
                    
                    // Update progress based on the duration of segments processed
                    totalProcessedDuration += segment.duration;
                    state.encodingProgress = Math.round((totalProcessedDuration / totalDuration) * 90); // Cap at 90% for this phase
                }

                // Step 2: Concatenate all individual clips into the final video
                const concatFileName = 'filelist.txt';
                ffmpeg.FS('writeFile', concatFileName, concatFileContent.join('\n'));
                
                state.encodingProgress = 95; // Update progress for concat step

                // CHANGE: Output filename is now .webm
                const outputFilename = 'output.webm';
                await ffmpeg.run(
                    '-f', 'concat',
                    '-safe', '0',
                    '-i', concatFileName,
                    '-c', 'copy',
                    outputFilename
                );
                
                state.encodingProgress = 100;

                const data = ffmpeg.FS('readFile', outputFilename);
                // CHANGE: Use correct MIME type for WebM
                const videoBlob = new Blob([data.buffer], { type: 'video/webm' });

                return URL.createObjectURL(videoBlob);

            } catch (error) {
                console.error("Error during FFmpeg encoding:", error);
                throw error; // Re-throw the error to be caught by the calling function
            } finally {
                // Clean up FFmpeg instance
                try {
                    if (ffmpeg.isLoaded()) {
                       ffmpeg.exit();
                    }
                } catch (e) {
                    console.warn("FFmpeg exit error, may be normal.", e);
                }
            }
        }
        // =================================================================
        // == END: CORRECTED VIDEO ENCODING FUNCTION
        // =================================================================

        // --- Keyboard, Volume, and Other UI ---
        function handleKeyboardShortcuts(e) {
            if (!state.isDocumentaryActive || initialPromptInput === document.activeElement) return;
            e.preventDefault();
            switch(e.code) {
                case 'Space': togglePlayback(); break;
                case 'ArrowRight': audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 5); break;
                case 'ArrowLeft': audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 5); break;
                case 'KeyF': toggleFullscreen(); break;
                case 'KeyM': toggleMute(); break;
            }
        }
        function toggleMute() {
            audioPlayer.muted = !audioPlayer.muted;
            volumeHighIcon.classList.toggle('hidden', audioPlayer.muted);
            volumeMutedIcon.classList.toggle('hidden', !audioPlayer.muted);
            volumeSlider.value = audioPlayer.muted ? 0 : audioPlayer.volume;
        }
        function handleVolumeChange() {
            audioPlayer.volume = volumeSlider.value;
            audioPlayer.muted = volumeSlider.value == 0;
            volumeHighIcon.classList.toggle('hidden', audioPlayer.muted || audioPlayer.volume === 0);
            volumeMutedIcon.classList.toggle('hidden', !audioPlayer.muted && audioPlayer.volume > 0);
        }

        function setLoadingState(isLoading, text = '') { if (isLoading) { loadingState.classList.remove('hidden'); loadingState.style.display = 'flex'; loadingText.textContent = text; } else { loadingState.classList.add('hidden'); } }
        function showError(message) { 
            setLoadingState(false); 
            promptModal.classList.remove('hidden'); 
            initialPromptInput.value = ''; 
            initialPromptInput.placeholder = message; 
            // Reset the generate button state on error
            generateButton.disabled = false; 
            generateButton.innerHTML = 'Generate'; 
        }
        
        // --- Utilities ---
        function formatTime(seconds) { const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; }
        
        async function callProxyApi(type, payload, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch('/.netlify/functions/proxy-api', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type, payload })
                    });

                    if (response.ok) return response.json();
                    
                    if (response.status >= 500) {
                        console.warn(`Proxy API request failed with status ${response.status}. Retrying...`);
                        await new Promise(res => setTimeout(res, delay * (i + 1)));
                        continue;
                    }
                    
                    throw new Error(`Proxy API Error: ${response.status} ${response.statusText}`);

                } catch (error) {
                    console.warn(`Proxy call attempt ${i + 1} failed. Retrying...`, error);
                    if (i === retries - 1) throw error;
                    await new Promise(res => setTimeout(res, delay * (i + 1)));
                }
            }
            throw new Error('Proxy API request failed after multiple retries.');
        }
        
        async function generateText(systemPrompt, userPrompt) {
            const payload = { 
                contents: [{ parts: [{ text: userPrompt }] }], 
                systemInstruction: { parts: [{ text: systemPrompt }] }, 
                generationConfig: { responseMimeType: "application/json" }
            };
            for (let i = 0; i < 3; i++) {
                try {
                    const result = await callProxyApi('text', payload);
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!jsonText) throw new Error("No text content in API response.");
                    return JSON.parse(jsonText);
                } catch (error) {
                    console.warn(`Attempt ${i + 1} to generate and parse script failed. Retrying...`, error);
                    if (i === 2) throw new Error("Failed to generate a valid script from the AI after multiple attempts.");
                    await new Promise(res => setTimeout(res, 1500));
                }
            }
        }
        
        async function generateImage(prompt) {
            for (let i = 0; i < 3; i++) {
                try {
                    const payload = { instances: [{ prompt: `A scientifically accurate, photorealistic visualization of: ${prompt}. Cinematic documentary style, high detail.` }], parameters: { sampleCount: 1 } };
                    const result = await callProxyApi('image', payload);
                    const base64Data = result.predictions?.[0]?.bytesBase64Encoded;
                    if (base64Data) return `data:image/png;base64,${base64Data}`;
                    console.warn(`Image generation attempt ${i + 1} succeeded but returned no image data. Retrying...`);
                    await new Promise(res => setTimeout(res, 1500 * (i + 1)));
                } catch (error) {
                    console.error(`Image generation attempt ${i + 1} failed with error:`, error);
                    if (i === 2) throw error;
                    await new Promise(res => setTimeout(res, 1500 * (i + 1)));
                }
            }
            throw new Error("No image data in API response after multiple retries.");
        }

        async function generateAudio(text) {
            const payload = {
                contents: [{ parts: [{ text: `Narrate in a professional, clear, and engaging documentary voice, like a seasoned science communicator: ${text}` }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Charon" } } }
                },
                model: "gemini-2.5-flash-preview-tts"
            };
            const result = await callProxyApi('tts', payload);
            const audioData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            if (!audioData) throw new Error("No audio data in API response.");
            const pcmData = base64ToArrayBuffer(audioData);
            const pcm16 = new Int16Array(pcmData);
            // The TTS API returns single-channel (mono) audio at a 24000Hz sample rate.
            const wavBlob = pcmToWav(pcm16, 1, 24000);
            return URL.createObjectURL(wavBlob);
        }

        function getAudioDuration(url) { return new Promise(resolve => { const tempAudio = document.createElement('audio'); tempAudio.onloadedmetadata = () => resolve(tempAudio.duration); tempAudio.src = url; }); }
        function triggerDownload(url, filename) { const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); }
        function base64ToArrayBuffer(base64) { const binaryString = window.atob(base64); const len = binaryString.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i); return bytes.buffer; }
        function pcmToWav(pcmData, numChannels, sampleRate) { const buffer = new ArrayBuffer(44 + pcmData.length * 2); const view = new DataView(buffer); const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } }; writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + pcmData.length * 2, true); writeString(view, 8, 'WAVE'); writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2 * numChannels, true); view.setUint16(32, numChannels * 2, true); view.setUint16(34, 16, true); writeString(view, 36, 'data'); view.setUint32(40, pcmData.length * 2, true); for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); } return new Blob([view], { type: 'audio/wav' }); }
    });
    </script>
</body>
</html>
